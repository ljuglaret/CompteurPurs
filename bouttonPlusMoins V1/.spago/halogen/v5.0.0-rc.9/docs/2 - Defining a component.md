# Defining a component


Here's a somewhat contrived example of a Halogen component:

A runnable version of this is available in the [`basic` example](../examples/basic/).

``` purescript
module Example.Basic.Button (component) where

import Prelude

import Data.Maybe (Maybe(..))
import Halogen as H
import Halogen.HTML as HH
import Halogen.HTML.Events as HE
import Halogen.HTML.Properties as HP

type State = { enabled :: Boolean }

data Action = Toggle

component :: forall q i o m. H.Component HH.HTML q i o m
component =
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }

initialState :: forall i. i -> State
initialState _ = { enabled: false }

render :: forall m. State -> H.ComponentHTML Action () m
render state =
  let
    label = if state.enabled then "On" else "Off"
  in
    HH.button
      [ HP.title label
      , HE.onClick \_ -> Just Toggle
      ]
      [ HH.text label ]

handleAction ∷ forall o m. Action → H.HalogenM State Action () o m Unit
handleAction = case _ of
  Toggle ->
    H.modify_ \st -> st { enabled = not st.enabled }
```
A runnable version of this is available in the [`basic` example](../examples/basic/).

This is a component for a button that displays its current state as the label, and is toggled when clicked by a user. The rest of this chapter will break down the elements involved here.

## Halogen `Component`

The `Component` type combines all of the state management and rendering information for a given component. Over this and the coming sections, we will examine it's type signature and how to use it effectively. The `Component` type wraps another type used for evaluation called [`HalogenM`][Halogen.Query.HalogenM.HalogenM].

``` purescript
component :: forall q i o m. H.Component HH.HTML q i o m
```

Let's examine each part of this type for clarity:

- `H.Component` - this is the constructor for our component type
- `HH.HTML` - this defines the surface type we will be rendering to, this could include any number of rendering structures, though the most common is HTML.
- `q` - the type of _queries_ to this component.
- `i` - the type of _input_ to this component, this would be a value received from the parent or from a mounting function.
- `o` - the type of output messages generated by this component, this would be a value sent to a parent component.
- `m` - the underlying monad that this component uses for evaluation, by default this uses HalogenM, which has no effect capabilities on its own, However you can easily constrain `m` to be a monad with `MonadAff` and/or `MonadEffect` typeclass instances. (such as `Effect`, `Aff`, or a monad transformer of your choice), this will require the `hoist` function, which we will discuss in a later section.

The component is constructed using the `mkComponent` function, which takes a record used to describe relevant values and functions used for the components operation.

The record `mkComponent` takes must include an `initialState` row, which is a function of type `Input -> State` (both `Input` and `State` are types you will define locally in your component module, or types you will substitute with `Unit`, for example this component accepts no input). If the component will initialize with a predefined state, such as in our case (`{ enabled: False }`), the initialState function will be `const { enabled: False}`, or a function equivalent to it as seen above.

The next row in the argument to `mkComponent` will be `render`, which tells the component how to render for a given state,  this is a pure function from state to a rendered structure, and does not perform any side effects directly, the rendering itself will be handled by Halogen.

The final row in the argument to `mkComponent` is `eval`, eval will be covered in depth over the coming sections, but in short, all effectful action occurs in the functions provided to eval (`eval` itself is a record type with functions for handling _actions_, _input_, _queries_, and lifecycle-related effects).  lifecycle will be covered in a later chapter.

`Component` gives us the ability to perform actions during the evaluation of input, queries, lifecycle, and actions. The most obvious of these is the ability to manipulate the state of a component. There's a [`MonadState`][Control.Monad.State.Class.MonadState] instance that allows us to do these:

- [`get`][Control.Monad.State.Class.get] retrieves the current state value
- [`gets f`][Control.Monad.State.Class.gets] retrieves the state value and applies `f` - generally used to extract a part of the state (for example, `gets _.someProp` when using a record state).
- [`modify_ f`][Control.Monad.State.Class.modify_] updates the stored state value by applying `f` to it.
- [`put`][Control.Monad.State.Class.put] overwrites the entire current state value. Be careful with this!

Halogen re-exports these functions from the main `Halogen` module for convenience.

There are a range of other useful instances for `HalogenM`, but we'll cover those elsewhere in the guide.

## State

For this button component, we just need a simple state type: is the button on or off?

```purescript
type State = { enabled :: Boolean }
```
We could easily adjust this to use a sum type for various button states by using a type such as:

```purescript
data ButtonEnabled = ButtonOn | ButtonOff
type State = { enabled :: ButtonEnabled }
```

The initial value for state is defined with the `initialstate` row provided to `mkComponent`.

It should be noted that while most components will require a record type or ADT for state, it is not strictly necessary and we could very easily make `type State = Bool`.

## Rendering

Now that we know our state, how do we represent that state as rendered output?

``` purescript
render :: forall m. State -> H.ComponentHTML Action () m
```

Looking at the type we can see that the state is the input, and a [`ComponentHTML`][Halogen.Component.ComponentHTML] value is produced. This is a pure function, so no state changes can take place during `render`.

We also supply the _Action_ types that the rendered `ComponentHtml` can raise, and the `ChildSlots` for the component (in this case we have no childSlots, so the parameter is the empty row `()`). Finally, we provide a monad type variable which decribes the monad the render function will run in, by Convention, this will almost always be the type variable `m`.

### The HTML DSL

Halogen provides a HTML DSL (domain specific language) to construct [`ComponentHTML`][Halogen.Component.ComponentHTML] values. The DSL gives us a type-safe way of declaring HTML so that only suitable properties can be applied to each element. The resulting value is not actual HTML, it is a representation that is later applied to the DOM by Halogen.

In the code examples, the `HH` prefix is for elements, `HP` is for properties, and `HE` is for event handlers. These names are the suggested convention to use whenever referring to the [`Halogen.HTML`][Halogen.HTML], [`Halogen.HTML.Properties`][Halogen.HTML.Properties], and [`Halogen.HTML.Events`][Halogen.HTML.Events] modules.

Element functions generally follow this scheme:

```
elementName [ ... properties ... ] [ ... children ... ]
```

There are exceptions such as elements that expect no properties, such as `text`. In the case of `text`, the element only accepts a single `String`. Some other elements accept no children, such as a `br`, or `textarea`. For every element there is also a version that skips the properties array, usable by affixing an underscore to the name ([`button_`][Halogen.HTML.Elements.button_] instead of [`button`][Halogen.HTML.Elements.button]).

As with traditional HTML, event handlers are provided as element properties, and are used to feed action queries back to the component:

``` purescript
  let
    label = if state.enabled then "On" else "Off"
  in
    HH.button
      [ HP.title label
      , HE.onClick \_ -> Just Toggle
      ]
      [ HH.text label ]
```

The above code sample shows a button element which will raise the action `Toggle` when clicked.

The `onClick` function from `Halogen.HTML.Events` will accept any function from an `Event` (found in `Web.Event.Event`) to a `Maybe Action`, if the function returns a `Just`, then the `Action` will be evaluated.

It is common (in order for our component to be interesting), to either set bound variables to be equal to some part of our state (such as `label` above), or to use case matching to render differently based on our state values.

If you wish to build a component that does not need to change its own state, and works more-or-less as a combinator function from a given value to HTML output, take a look at our section on _Custom Elements_.

## Action Types

_Actions_ can be raised within a component to trigger evaluation, causing some change within a component or an effect, they then return the `Unit` value. A constructor for an _action_ will look something like this:

``` purescript
data Action = Toggle
```

The _action_ may carry parameters (such as a form input value, or the HTML event itself, particularly if effects need to be applied to it, such as `preventDefault`), however it is not necessary for any action to carry parameters, as seen here.

### Evaluating actions

Let's look at our Component's `eval` structure:

```purescript
  H.mkComponent
    { initialState
    , render
    , eval: H.mkEval $ H.defaultEval { handleAction = handleAction }
    }
```

Here we use the `mkEval` convenience function, and provide it with a modified `defaultEval`, which is a no-op by default.

We've added our own handleAction function, which is where we determine which effects are necessary based upon the _action_ that was raised.

Here's our handleAction:

```purescript
handleAction ∷ forall o m. Action → H.HalogenM State Action () o m Unit
handleAction = case _ of
  Toggle ->
    H.modify_ \st -> st { enabled = not st.enabled }
```

Let's examine the type signature of `handleAction` a little closer.

For this component's `Action` type, we will return a `HalogenM` with this component's state, action, input, output, and underlying monad,  and an underlying value of unit, which is everything Halogen needs in order to render the next state of the component. The only thing that is likely to change in the return value is the `State` value, which we will modify using the state helpers `get`, `gets` `modify` and `put` described above.

So when we receive the `Toggle` action you can see that we call `modify` on our state, and modify it by calling `not`, flipping the boolean and causing a re-render.

Given that we are operating in a monad with state capabilities, so far the evaluation is entirely pure, for effectful evaluation, see our later chapters on random effects and ajax.

Next up, let's take a look at how to create a component that can [do something effectful][handling-effects] other than update its own state.

[Control.Monad.State.Class.get]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:get "Control.Monad.State.Class.get"
[Control.Monad.State.Class.gets]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:gets "Control.Monad.State.Class.gets"
[Control.Monad.State.Class.modify_]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:modify_ "Control.Monad.State.Class.modify_"
[Control.Monad.State.Class.MonadState]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#t:MonadState "Control.Monad.State.Class.MonadState"
[Control.Monad.State.Class.put]: https://pursuit.purescript.org/packages/purescript-transformers/4.1.0/docs/Control.Monad.State.Class#v:put "Control.Monad.State.Class.put"
[Data.NaturalTransformation]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.NaturalTransformation "Data.NaturalTransformation"
[Data.Void.Void]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.Void#t:Void "Data.Void.Void"
[Data.Unit.Unit]: https://pursuit.purescript.org/packages/purescript-prelude/4.0.0/docs/Data.Unit#t:Unit "Data.Unit.Unit"
[Halogen.Component.component-1]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#v:component "Halogen.Component.component"
[Halogen.Component.Component]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:Component "Halogen.Component.Component"
[Halogen.Component.ComponentHTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:ComponentHTML "Halogen.Component.ComponentHTML"
[Halogen.Component.ComponentSpec]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Component#t:ComponentSpec "Halogen.Component.ComponentSpec"
[Halogen.HTML.Core.HTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Core#t:HTML "Halogen.HTML.Core.HTML"
[Halogen.HTML.Elements.button_]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Elements#v:button_ "Halogen.HTML.Elements.button_"
[Halogen.HTML.Elements.button]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Elements#v:button "Halogen.HTML.Elements.button"
[Halogen.HTML.Events.input_]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events#v:input_ "Halogen.HTML.Events.input_"
[Halogen.HTML.Events.input]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events#v:input "Halogen.HTML.Events.input"
[Halogen.HTML.Events]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Events "Halogen.HTML.Events"
[Halogen.HTML.Properties]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML.Properties "Halogen.HTML.Properties"
[Halogen.HTML]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.HTML "Halogen.HTML"
[Halogen.Query.HalogenM.HalogenM]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query.HalogenM#t:HalogenM "Halogen.Query.HalogenM.HalogenM"
[Halogen.Query.HalogenM.raise]: https://pursuit.purescript.org/packages/purescript-halogen/docs/Halogen.Query.HalogenM#v:raise "Halogen.Query.HalogenM.raise"

[parent-child-components]: 5%20-%20Parent%20and%20child%20components.md "Parent and child components"
[handling-effects]: 3%20-%20Handling%20effects.md "Handling effects"
[running-components]: 4%20-%20Running%20a%20component.md "Running a component"
